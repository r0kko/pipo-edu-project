// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: passes.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPass = `-- name: CreatePass :one
INSERT INTO passes (owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at
`

type CreatePassParams struct {
	OwnerUserID  uuid.UUID      `json:"owner_user_id"`
	PlateNumber  string         `json:"plate_number"`
	VehicleBrand sql.NullString `json:"vehicle_brand"`
	VehicleColor sql.NullString `json:"vehicle_color"`
	Status       string         `json:"status"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
	UpdatedBy    uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) CreatePass(ctx context.Context, arg CreatePassParams) (Pass, error) {
	row := q.db.QueryRowContext(ctx, createPass,
		arg.OwnerUserID,
		arg.PlateNumber,
		arg.VehicleBrand,
		arg.VehicleColor,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Pass
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.PlateNumber,
		&i.VehicleBrand,
		&i.VehicleColor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const getPassByID = `-- name: GetPassByID :one
SELECT id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at FROM passes WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPassByID(ctx context.Context, id uuid.UUID) (Pass, error) {
	row := q.db.QueryRowContext(ctx, getPassByID, id)
	var i Pass
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.PlateNumber,
		&i.VehicleBrand,
		&i.VehicleColor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const getPassByIDAny = `-- name: GetPassByIDAny :one
SELECT id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at FROM passes WHERE id = $1
`

func (q *Queries) GetPassByIDAny(ctx context.Context, id uuid.UUID) (Pass, error) {
	row := q.db.QueryRowContext(ctx, getPassByIDAny, id)
	var i Pass
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.PlateNumber,
		&i.VehicleBrand,
		&i.VehicleColor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}

const listPasses = `-- name: ListPasses :many
SELECT id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at FROM passes
WHERE ($1::bool) OR deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPassesParams struct {
	Column1 bool  `json:"column_1"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListPasses(ctx context.Context, arg ListPassesParams) ([]Pass, error) {
	rows, err := q.db.QueryContext(ctx, listPasses, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pass
	for rows.Next() {
		var i Pass
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.PlateNumber,
			&i.VehicleBrand,
			&i.VehicleColor,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPassesByOwner = `-- name: ListPassesByOwner :many
SELECT id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at FROM passes
WHERE owner_user_id = $1 AND (($2::bool) OR deleted_at IS NULL)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListPassesByOwnerParams struct {
	OwnerUserID uuid.UUID `json:"owner_user_id"`
	Column2     bool      `json:"column_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListPassesByOwner(ctx context.Context, arg ListPassesByOwnerParams) ([]Pass, error) {
	rows, err := q.db.QueryContext(ctx, listPassesByOwner,
		arg.OwnerUserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pass
	for rows.Next() {
		var i Pass
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.PlateNumber,
			&i.VehicleBrand,
			&i.VehicleColor,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restorePass = `-- name: RestorePass :exec
UPDATE passes
SET deleted_at = NULL,
    updated_at = now(),
    updated_by = $2
WHERE id = $1
`

type RestorePassParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) RestorePass(ctx context.Context, arg RestorePassParams) error {
	_, err := q.db.ExecContext(ctx, restorePass, arg.ID, arg.UpdatedBy)
	return err
}

const searchPassesByPlate = `-- name: SearchPassesByPlate :many
SELECT id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at FROM passes
WHERE deleted_at IS NULL AND plate_number ILIKE $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchPassesByPlateParams struct {
	PlateNumber string `json:"plate_number"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) SearchPassesByPlate(ctx context.Context, arg SearchPassesByPlateParams) ([]Pass, error) {
	rows, err := q.db.QueryContext(ctx, searchPassesByPlate, arg.PlateNumber, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pass
	for rows.Next() {
		var i Pass
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.PlateNumber,
			&i.VehicleBrand,
			&i.VehicleColor,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePass = `-- name: SoftDeletePass :exec
UPDATE passes
SET deleted_at = now(),
    updated_at = now(),
    updated_by = $2
WHERE id = $1 AND deleted_at IS NULL
`

type SoftDeletePassParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) SoftDeletePass(ctx context.Context, arg SoftDeletePassParams) error {
	_, err := q.db.ExecContext(ctx, softDeletePass, arg.ID, arg.UpdatedBy)
	return err
}

const updatePass = `-- name: UpdatePass :one
UPDATE passes
SET plate_number = $2,
    vehicle_brand = $3,
    vehicle_color = $4,
    status = $5,
    updated_at = now(),
    updated_by = $6
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, owner_user_id, plate_number, vehicle_brand, vehicle_color, status, created_at, updated_at, created_by, updated_by, deleted_at
`

type UpdatePassParams struct {
	ID           uuid.UUID      `json:"id"`
	PlateNumber  string         `json:"plate_number"`
	VehicleBrand sql.NullString `json:"vehicle_brand"`
	VehicleColor sql.NullString `json:"vehicle_color"`
	Status       string         `json:"status"`
	UpdatedBy    uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) UpdatePass(ctx context.Context, arg UpdatePassParams) (Pass, error) {
	row := q.db.QueryRowContext(ctx, updatePass,
		arg.ID,
		arg.PlateNumber,
		arg.VehicleBrand,
		arg.VehicleColor,
		arg.Status,
		arg.UpdatedBy,
	)
	var i Pass
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.PlateNumber,
		&i.VehicleBrand,
		&i.VehicleColor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedAt,
	)
	return i, err
}
